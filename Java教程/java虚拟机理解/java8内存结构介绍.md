## java8内存结构介绍

&emsp;java虚拟机在jdk8改变了许多，网络上各种解释都有，在查阅了官方文档以及一下大佬的解释以后，我来粗浅的介绍一下我理解的java8的内存结构。

### 目录
1. [内存结构图总结](#1)
2. [虚拟机内存与本地内存的区别](#2)
3. [java运行时数据区域](#3)
   1. [程序计数器（Program Counter Register）](#31)
   2. [虚拟机栈（JVM Stacks）](#32)
   3. [本地方法栈（Native Method Stacks）](#33)
      1. [什么是Native方法？](#331)
   4. [](#34)
   5. [](#35)
4. [直接内存](#4)
5. [常见问题](#5)
6. [](#6)

---
### <a id=1>java8内存结构图</a>

![java内存结构](https://cdn.jsdelivr.net/gh/leiyu1997/PicBed@master/blogs/pictures/java内存结构.png 'designed by leiyu')

---
### <a id=2>虚拟机内存与本地内存的区别</a>

&emsp;Java虚拟机在执行的时候会把管理的内存分配成不同的区域，这些区域被称为`虚拟机内存`，同时，对于虚拟机没有直接管理的物理内存，也有一定的利用，这些被利用却不在虚拟机内存数据区的内存，我们称它为`本地内存`，这两种内存有一定的区别：
- JVM内存
  - 受虚拟机内存大小的参数控制，当大小超过参数设置的大小时就会报OOM
- 本地内存
  - 本地内存不受虚拟机内存参数的限制，只受物理内存容量的限制
  - 虽然不受参数的限制，但是如果内存的占用超出物理内存的大小，同样也会报OOM

---
### <a id=3>java运行时数据区域</a>

&emsp;java虚拟机在执行过程中会将所管理的内存划分为不同的区域，有的随着线程产生和消失，有的随着java进程产生和消失，根据《Java虚拟机规范》的规定，运行时数据区分为以下一个区域：

#### <a id=31>程序计数器（Program Counter Register）</a>

&emsp;程序计数器就是当前线程所执行的字节码的行号指示器，通过改变计数器的值，来选取下一行指令，通过他来实现跳转、循环、恢复线程等功能。
- 在任何时刻，一个处理器内核只能运行一个线程，多线程是通过线程轮流切换，分配时间来完成的，这就需要有一个标志来记住每个线程执行到了哪里，这里便需要到了程序计数器。
- 所以，程序计数器是`线程私有`的，每个线程都已自己的程序计数器。

#### <a id=32>虚拟机栈（JVM Stacks）</a>

![虚拟机栈](https://cdn.jsdelivr.net/gh/leiyu1997/PicBed@master/blogs/pictures/虚拟机栈.png)

&emsp;虚拟机栈是`线程私有`的，随线程生灭。虚拟机栈描述的是线程中的方法的内存模型：
- 每个方法被执行的时候，都会在虚拟机栈中同步创建一个栈帧（stack frame）
- 每个栈帧的包含如下的内容
  - 局部变量表
    - 局部变量表中存储着方法里的**java基本数据类型**（byte/boolean/char/int/long/double/float/short）以及**对象的引用**（注：这里的基本数据类型指的是方法内的局部变量）
  - 操作数栈
  - 动态连接
  - 方法返回地址
- 方法被执行时入栈，执行完后出栈

&emsp;虚拟机栈可能会抛出两种异常：
- 如果线程请求的栈深度大于虚拟机所规定的栈深度，则会抛出`StackOverFlowError`即栈溢出
- 如果虚拟机的栈容量可以动态扩展，那么当虚拟机栈申请不到内存时会抛出`OutOfMemoryError`即OOM内存溢出

#### <a id=33>本地方法栈（Native Method Stacks）</a>

&emsp;本地方法栈与虚拟机栈的作用是相似的,都会抛出`OutOfMemoryError`和`StackOverFlowError`，都是`线程私有`的，主要的区别在于：
- 虚拟机栈执行的是java方法
- 本地方法栈执行的是native方法

    ##### <a id=331>什么是Native方法？</a>
    &emsp;由于java是一门高级语言，离硬件底层比较远，有时候无法操作底层的资源，于是，java添加了`native`关键字，被`native`关键字修饰的方法可以用其他语言重写，这样，我们就可以写一个本地方法，然后用C语言重写，这样来操作底层资源。当然，使用了native方法会导致系统的可移植性不高，这是需要注意的。

#### <a id=34>Java堆（Java Heap）</a>


#### <a id=35>方法区(Method Area)</a>

&emsp;方法区绝对是网上所有关于java内存结构文章争论的焦点，因为方法区的实现在java8做了一次大革新，现在我们来讨论一下：

方法区是所有`线程共享`的内存，在java8以前是放在JVM内存中的，由永久代实现，受JVM内存大小参数的限制，在java8中移除了永久代的内容，方法区由`元空间(Meta Space)`实现，并直接放到了本地内存中，并且将原来放在方法区的`字符串常量池`和`静态变量`都转移到了Java堆中，

---
### <a id=4>直接内存</a>

&emsp;直接内存位于本地内存，不属于JVM内存，但是也会在物理内存耗尽的时候报OOM,所以也讲一下。
直接内存是用来优化IO效率的，java新版本中增加了buffer类来优化IO,而Buffer类的缓冲区便放在直接内存中。

---
### <a id=5>常见问题</a>

#### <a id=51>成员变量、局部变量、类变量分别存储在内存的什么地方？</a>

- 类变量
  - 类变量是用static修饰符修饰，定义在方法外的变量，随着java进程产生和销毁
  - 在java8之前把静态变量存放于方法区，在java8时存放在堆中
- 成员变量
  - 成员变量是定义在类中，但是没有static修饰符修饰的变量，随着类的实例产生和销毁，是类实例的一部分
  - 由于是实例的一部分，在类初始化的时候，从运行时常量池取出直接引用或者值，与初始化的对象一起放入堆中
- 局部变量
  - 局部变量是定义在类的方法中的变量
  - 在所在方法被调用时放入虚拟机栈的栈帧中，方法执行结束后从虚拟机栈中弹出，所以存放在虚拟机栈中

#### <a id=52>由final修饰的常量存放在哪里？</a>

&emsp;`final`关键字并不影响在内存中的位置，具体位置请参考上一问题。

#### 


