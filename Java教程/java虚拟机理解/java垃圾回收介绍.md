# java垃圾回收介绍

<!-- TOC -->

- [什么是垃圾？](#什么是垃圾)
- [哪些是垃圾？](#哪些是垃圾)
- [垃圾收集算法](#垃圾收集算法)
  - [分代收集理论](#分代收集理论)
    - [跨代引用与解决办法（记忆集）](#跨代引用与解决办法记忆集)
  - [标记-清除（Mark-Sweep）算法](#标记-清除mark-sweep算法)

<!-- /TOC -->


&emsp;java与C/C++的有一个很显著的区别是，java回收失效的对象是自动的,即垃圾收集（Garbage Collection），而C/C++则要程序员自己释放内存，这样做有利有弊，但是对于程序员来说绝对是省心了不少，也减少了内存溢出的产生，作为一个程序员，如果想要进阶，垃圾收集是一定要明白的内容，向大家推荐周志明老师的《深入理解Java虚拟机》，我对JVM的绝大部分理解都来自于该书，下面我来介绍一下我对垃圾回收的理解。

&emsp;垃圾回收（GC）,顾名思义就是对内存中的垃圾进行回收，自然，我们也发出了哲学三问：
- 什么是垃圾？
- 哪些是垃圾？
- 怎么回收垃圾？

接下来我将一一回答这些问题

---
## 什么是垃圾？

垃圾回收主要发生于java堆中（方法区也有垃圾回收，但不占主要部分所以本文不涉及），堆中存放着java世界中所有的对象实例，这些对象实例占据了堆的绝大部分，我们要回收的，便是其中那些不再使用的对象实例，这些不再使用的对象实例，便是垃圾。

---
## 哪些是垃圾？

垃圾回收首先遇到的问题便是要回收哪些对象，首先，存活的对象肯定是不能回收的，所以我们要回收的就是哪些没有存活的对象，那么怎么判断一个对象是否存活呢？在Java中，一个对象是否存活主要是由他是否被引用来判断的，这相当好理解，一个没有被引用的对象就是一个没有被用到的对象，用不到的对象自然就是垃圾了。而根据引用，目前有两种方法用来判断对象是否存活：
- **引用计数法**
  - 使用引用计数法，会在对象中加入一个引用计数器，有一个地方引用时计数器就加一；引用失效时，计数器就减一；当计数器为0的时候这个对象就不可再用了，即变成了垃圾，等待回收。
  - 引用计数法虽然简单，但有一些问题不好处理，比如`无法解决循环引用`，当两个对象互相引用，那么这两个对象就永远不会被清除。
- **可达性分析算法**
  - 这个算法的思想是：通过一系列被称为`GCRoots`的根对象作为起始节点集，从这些节点开始根据引用关系向下检索，遍历的路径被称为‘引用链’，被检索到的对象代表正在使用（即存活），而遍历完后，没有被遍历到的对象则是不可达的，也说明这个对象不可能被使用（即垃圾）。
  - 这样避免了循环引用的出现，因为即使两个对象出现了互相引用，如果这两个对象没有被其他存活的对象引用，那么这两个对象就不会被遍历到，也就变成了垃圾
  - 在java中，`GCRoots`对象主要包括以下几种：
    - 虚拟机栈中引用的对象
    - 本地方法栈中引用的对象
    - 静态变量中引用的对象
    - 常量池中引用的对象（字符串常量池、运行时常量池）
    - 虚拟机内部的引用（异常对象、class对象）
    - 加锁的对象
  - 注：`目前所有的垃圾收集器均采用可达性分析算法来判断对象是否存活`。

---
## 垃圾收集算法

讲完了什么是垃圾，我们来看一下怎么回收垃圾，目前，主要由两种垃圾收集算法，分别是：
- 引用计数式垃圾收集（Reference Counting GC）也叫‘直接垃圾收集’
- 追踪式垃圾收集（Tracing GC）也叫‘间接垃圾收集’

由于引用计数式垃圾收集在主流垃圾收集器中均未使用，本节只介绍追踪式垃圾收集

### 分代收集理论

最初的几款垃圾收集器都遵循了分代收集的设计思想，所以有必要了解一下什么是分代收集。根据程序运行的实际情况，人们总结了以下两条规律：
- 绝大多数对象都是朝生夕灭的
- 熬过越多次垃圾收集的对象就越难以消亡

根据这两条规律，在设计垃圾收集器时，人们将堆空间划分为不同的区域，用不同的回收算法回收不同特点的对象。比如一个区域的对象大部分都是朝生夕灭的，而另一个区域的对象大部分都是一直存活的，那么显然，回收的算法选择就不同。具体到java中，在老版本商用的java虚拟机中，一般将堆区分为`新生代`和`老年代`两个部分。
- 新生代
  - 顾名思义，新生代的对象都是年纪比较小的，每次垃圾回收之后大部分都会死去，而存活下来的对象将会逐步被放入老年代中。
- 老年代
  - 老年代中存放哪些在新生代垃圾回收过程中存活下来的对象。

#### 跨代引用与解决办法（记忆集）
由于引入了分代收集的理念，也由此带了新的问题，那就是`跨代引用`。我们要清理新生代垃圾的时候，其实完全有可能有老年代的对象引用了新生代的对象，这就不得不在每次根节点枚举的时候再额外遍历老年代的所有对象，这显然效率很低，所以，为了解决跨代引用的问题，引入了`记忆集`结构。在Hotspot虚拟机实现中介绍

### 标记-清除（Mark-Sweep）算法
