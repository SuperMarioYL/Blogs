# java垃圾回收介绍

&emsp;java与C/C++的有一个很显著的区别是，java回收失效的对象是自动的,即垃圾收集（Garbage Collection），而C/C++则要程序员自己释放内存，这样做有利有弊，但是对于程序员来说绝对是省心了不少，也减少了内存溢出的产生，作为一个程序员，如果想要进阶，垃圾收集是一定要明白的内容，向大家推荐周志明老师的《深入理解Java虚拟机》，我对JVM的绝大部分理解都来自于该书，下面我来介绍一下我对垃圾回收的理解。

&emsp;垃圾回收（GC）,顾名思义就是对内存中的垃圾进行回收，自然，我们也发出了哲学三问：
- 什么是垃圾？
- 哪些是垃圾？
- 怎么回收垃圾？

接下来我将一一回答这些问题

## 目录


---
## <a id=1>什么是垃圾？</a>

垃圾回收主要发生于java堆中（方法区也有垃圾回收，但不占主要部分所以本文不涉及），堆中存放着java世界中所有的对象实例，这些对象实例占据了堆的绝大部分，我们要回收的，便是其中那些不再使用的对象实例，这些不再使用的对象实例，便是垃圾。

---
## <a id=2>哪些是垃圾？</a>

垃圾回收首先遇到的问题便是要回收哪些对象，首先，存活的对象肯定是不能回收的，所以我们要回收的就是哪些没有存活的对象，那么怎么判断一个对象是否存活呢？在Java中，一个对象是否存活主要是由他是否被引用来判断的，这相当好理解，一个没有被引用的对象就是一个没有被用到的对象，用不到的对象自然就是垃圾了。而根据引用，目前有两种方法用来判断对象是否存活：
- **引用计数法**
  - 使用引用计数法，会在对象中加入一个引用计数器，有一个地方引用时计数器就加一；引用失效时，计数器就减一；当计数器为0的时候这个对象就不可再用了，即变成了垃圾，等待回收。
  - 引用计数法虽然简单，但有一些问题不好处理，比如`无法解决循环引用`，当两个对象互相引用，那么这两个对象就永远不会被清除。
- **可达性分析算法**
  - 这个算法的思想是：通过一系列被称为`GCRoots`的根对象作为起始节点集，从这些节点开始根据引用关系向下检索，遍历的路径被称为‘引用链’，被检索到的对象代表正在使用（即存活），而遍历完后，没有被遍历到的对象则是不可达的，也说明这个对象不可能被使用（即垃圾）。
  - 这样避免了循环引用的出现，因为即使两个对象出现了互相引用，如果这两个对象没有被其他存活的对象引用，那么这两个对象就不会被遍历到，也就变成了垃圾
  - 在java中，`GCRoots`对象主要包括以下几种：
    - 虚拟机栈中引用的对象
    - 本地方法栈中引用的对象
    - 静态变量中引用的对象
    - 常量池中引用的对象（字符串常量池、运行时常量池）
    - 虚拟机内部的引用（异常对象、class对象）
    - 加锁的对象
  - 注：`目前所有的垃圾收集器均采用可达性分析算法来判断对象是否存活`。

## <a id=3>垃圾收集算法</a>