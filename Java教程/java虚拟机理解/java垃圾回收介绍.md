# java垃圾回收介绍

<!-- TOC -->

- [**什么是垃圾？**](#什么是垃圾)
- [**哪些是垃圾？（对象存活判定方法）**](#哪些是垃圾对象存活判定方法)
- [**垃圾收集算法**](#垃圾收集算法)
  - [**分代收集理论**](#分代收集理论)
    - [**跨代引用与解决办法（记忆集）**](#跨代引用与解决办法记忆集)
  - [**标记-清除（Mark-Sweep）算法**](#标记-清除mark-sweep算法)
  - [**标记-复制（Mark-Copy）算法**](#标记-复制mark-copy算法)
  - [**标记-整理（Mark-Compact）算法**](#标记-整理mark-compact算法)
- [**HotSpot的算法实现细节**](#hotspot的算法实现细节)
  - [**根节点枚举**](#根节点枚举)

<!-- /TOC -->


&emsp;java与C/C++的有一个很显著的区别是，java回收失效的对象是自动的,即垃圾收集（Garbage Collection），而C/C++则要程序员自己释放内存，这样做有利有弊，但是对于程序员来说绝对是省心了不少，也减少了内存溢出的产生，作为一个程序员，如果想要进阶，垃圾收集是一定要明白的内容，向大家推荐周志明老师的《深入理解Java虚拟机》，我对JVM的绝大部分理解都来自于该书，下面我来介绍一下我对垃圾回收的理解。

&emsp;垃圾回收（GC）,顾名思义就是对内存中的垃圾进行回收，自然，我们也发出了哲学三问：
- 什么是垃圾？
- 哪些是垃圾？
- 怎么回收垃圾？

接下来我将一一回答这些问题

---
## **什么是垃圾？**

垃圾回收主要发生于java堆中（方法区也有垃圾回收，但不占主要部分所以本文不涉及），堆中存放着java世界中所有的对象实例，这些对象实例占据了堆的绝大部分，我们要回收的，便是其中那些不再使用的对象实例，这些不再使用的对象实例，便是垃圾。

---
## **哪些是垃圾？（对象存活判定方法）**

垃圾回收首先遇到的问题便是要回收哪些对象，首先，存活的对象肯定是不能回收的，所以我们要回收的就是哪些没有存活的对象，那么怎么判断一个对象是否存活呢？在Java中，一个对象是否存活主要是由他是否被引用来判断的，这相当好理解，一个没有被引用的对象就是一个没有被用到的对象，用不到的对象自然就是垃圾了。而根据引用，目前有两种方法用来判断对象是否存活：
- **引用计数法**
  - 使用引用计数法，会在对象中加入一个引用计数器，有一个地方引用时计数器就加一；引用失效时，计数器就减一；当计数器为0的时候这个对象就不可再用了，即变成了垃圾，等待回收。
  - 引用计数法虽然简单，但有一些问题不好处理，比如`无法解决循环引用`，当两个对象互相引用，那么这两个对象就永远不会被清除。
- **可达性分析算法**
  - 这个算法的思想是：通过一系列被称为`GCRoots`的根对象作为起始节点集，从这些节点开始根据引用关系向下检索，遍历的路径被称为‘引用链’，被检索到的对象代表正在使用（即存活），而遍历完后，没有被遍历到的对象则是不可达的，也说明这个对象不可能被使用（即垃圾）。
  - 这样避免了循环引用的出现，因为即使两个对象出现了互相引用，如果这两个对象没有被其他存活的对象引用，那么这两个对象就不会被遍历到，也就变成了垃圾
  - 在java中，`GCRoots`对象主要包括以下几种：
    - 虚拟机栈中引用的对象
    - 本地方法栈中引用的对象
    - 静态变量中引用的对象
    - 常量池中引用的对象（字符串常量池、运行时常量池）
    - 虚拟机内部的引用（异常对象、class对象）
    - 加锁的对象
  - 注：`目前所有的垃圾收集器均采用可达性分析算法来判断对象是否存活`。

---
## **垃圾收集算法**

讲完了什么是垃圾，我们来看一下怎么回收垃圾，目前，主要由两种垃圾收集算法，分别是：
- 引用计数式垃圾收集（Reference Counting GC）也叫‘直接垃圾收集’
- 追踪式垃圾收集（Tracing GC）也叫‘间接垃圾收集’

由于引用计数式垃圾收集在主流垃圾收集器中均未使用，本节只介绍追踪式垃圾收集

### **分代收集理论**

最初的几款垃圾收集器都遵循了分代收集的设计思想，所以有必要了解一下什么是分代收集。根据程序运行的实际情况，人们总结了以下两条规律：
- 绝大多数对象都是朝生夕灭的
- 熬过越多次垃圾收集的对象就越难以消亡

根据这两条规律，在设计垃圾收集器时，人们将堆空间划分为不同的区域，用不同的回收算法回收不同特点的对象。比如一个区域的对象大部分都是朝生夕灭的，而另一个区域的对象大部分都是一直存活的，那么显然，回收的算法选择就不同。具体到java中，在老版本商用的java虚拟机中，一般将堆区分为`新生代`和`老年代`两个部分。
- 新生代
  - 顾名思义，新生代的对象都是年纪比较小的，每次垃圾回收之后大部分都会死去，而存活下来的对象将会逐步被放入老年代中。
- 老年代
  - 老年代中存放哪些在新生代垃圾回收过程中存活下来的对象。

#### **跨代引用与解决办法（记忆集）**
由于引入了分代收集的理念，也由此带了新的问题，那就是`跨代引用`。我们要清理新生代垃圾的时候，其实完全有可能有老年代的对象引用了新生代的对象，这就不得不在每次根节点枚举的时候再额外遍历老年代的所有对象，这显然效率很低，所以，为了解决跨代引用的问题，引入了`记忆集`结构，记忆集存储了老年代对象对新生代对象的引用（G1收集器实现的更复杂）。我将在Hotspot虚拟机实现中详细介绍。

### **标记-清除（Mark-Sweep）算法**

标记清除算法是最基础的垃圾收集算法，标记复制和标记整理算法都是在标记清除算法的基础上发展而来。
标记清除算法的执行过程是：

1. 标记需要回收的对象
2. 将被标记的对象回收

也可以反过来标记不需要回收的对象，然后将没有标记的对象回收。

标记清除算法有两个缺陷：
- 执行效率不稳定，如果一个区域有大量的对象都需要被标记然后回收，会导致效率变差
- 导致内存碎片化问题，标记清除后会产生大量不连续的内存空间，如果这时分配了一个占用内存很大的单个对象，会产生明明有空间却无法分配对象的情况，这对持续工作的系统非常麻烦。

`注：标记清除通常用于老年代收集`

### **标记-复制（Mark-Copy）算法**

为了解决标记清除算法中对大量对象被标记回收会导致效率变差以及内存碎片化的问题，标记复制算法应运而生。最基本的标记复制算法工作过程为：
1. 将内存空间分为两个部分
2. 每次垃圾回收时，将一个部分的内存空间中的存活对象标记
3. 将被标记的对象复制到另一个部分的内存空间
4. 将被复制的内存整个释放

标记复制算法解决了标记清除算法遇到的两个问题，但同时也存在自己的缺陷：
- 如果每次垃圾回收的时候一个内存部分都有大量的存活对象，会造成大量的内存复制开销。
- 将内存空间分成两部分，事实上我们能用的只有其中的一部分，造成了我们实际可用内存的减少

要解决标记复制算法遇到的问题，我们只要用`分代收集理论`就可以了。
- 根据分代收集理论，我们将整个堆内存分为新生代和老年代，而新生代绝大多数的对象熬不过第一次收集（根据专家的研究，新生代中98%的对象熬不过第一次收集），这样内存复制开销就小了；
- 并且由于新生代对象朝生夕死的特性，我们也不需要将内存空间分为大小差不多的两部分，以apple式回收为例：
  - 我们将新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和其中一块survivor。
  - 发生垃圾收集时，在使用中的Eden和survivor将存活的对象全部转入未使用的survivor中
  - Eden和survivor空间的比值为8:1，也就是说，在新生代中，只有10%的空间被浪费了
  - 当然，谁也不能保证每次垃圾回收只有10%的对象存活，如果超过survivor的空间限制，apple式回收将启用逃生门设计，使用老年代来存储存活对象，进行分配担保。

`注：标记复制算法主要用于新生代的垃圾收集`

### **标记-整理（Mark-Compact）算法**

新生代的特性非常适合使用标记复制算法，而对于老年代来说，由于大部分对象在垃圾收集中都可以存活，则标记复制算法并不适用；由于只需要回收少部分对象，标记清除算法就比较时候在老年代使用，但是标记清除算法没办法解决内存碎片化的问题，所以出现了标记整理算法。

`注：标记整理算法主要用于老年代的垃圾收集。`

标记整理算法的过程如下：
1. 标记要回收的对象
2. 将标记的对象清除
3. 把剩余的对象向内存空间的一端移动

由于移动对象的操作会使引用失效，所以，`在移动对象的时候，用户进程是必须要暂停的`，而不移动的话又会造成内存碎片化的问题，所以，一般采取的的是标记清除与标记整理共同使用，只有在内存碎片化不可接受时使用标记整理算法。

---
## **HotSpot的算法实现细节**

### **根节点枚举**